import numpy as np
import matplotlib.pyplot as plt
import copy
import time


def matrix_00(width=10):  # 电极元胞内跃迁，width不赋值时默认为10  
    h00 = np.zeros((width, width))
    for width0 in range(width-1):
        h00[width0, width0+1] = 1
        h00[width0+1, width0] = 1
    return h00


def matrix_01(width=10):  # 电极元胞间跃迁，width不赋值时默认为10
    h01 = np.identity(width)
    return h01


def matrix_LC(width=10, length=300):  # 左电极跳到中心区
    h_LC = np.zeros((width, width*length))
    for width0 in range(width):
        h_LC[width0, width0] = 1
    return h_LC


def matrix_CR(width=10, length=300):  # 中心区跳到右电极
    h_CR = np.zeros((width*length, width))
    for width0 in range(width):
        h_CR[width*(length-1)+width0, width0] = 1
    return h_CR


def matrix_center(width=10, length=300):  # 中心区哈密顿量
    hamiltonian = np.zeros((width*length, width*length))
    for length0 in range(length-1):
        for width0 in range(width):
            hamiltonian[width*length0+width0, width*(length0+1)+width0] = 1  # 长度方向跃迁
            hamiltonian[width*(length0+1)+width0, width*length0+width0] = 1 
    for length0 in range(length):
        for width0 in range(width-1):
            hamiltonian[width*length0+width0, width*length0+width0+1] = 1  # 宽度方向跃迁
            hamiltonian[width*length0+width0+1, width*length0+width0] = 1

    # 加三分之一势垒
    for j0 in range(np.int(length/3)):
        for i0 in range(np.int(width/3)): 
            hamiltonian[width*(np.int(length/3)+j0)+i0, width*(np.int(length/3)+j0)+i0]= 100
    return hamiltonian


def main():
    start_clock = time.clock()
    fermi_energy = 1
    width = 30
    length = 90
    h00 = matrix_00(width)
    h01 = matrix_01(width)
    G_n = Green_n(fermi_energy, h00, h01, width, length)
    # 下面是提取数据并画图
    direction_x = np.zeros((width, length))
    direction_y = np.zeros((width, length))
    for length0 in range(length-1):
        for width0 in range(width):
            direction_x[width0, length0] = G_n[width*length0+width0, width*(length0+1)+width0]
    for length0 in range(length):
        for width0 in range(width-1):
            direction_y[width0, length0] = G_n[width*length0+width0, width*length0+width0+1]
    # print(direction_x)
    # print(direction_y)
    X, Y = np.meshgrid(range(length), range(width))
    plt.quiver(X, Y, direction_x, direction_y)
    plt.show()
    end_clock = time.clock()
    print('CPU执行时间=', end_clock-start_clock)



def transfer_matrix(fermi_energy, h00, h01, dim):   # 转移矩阵T。dim是传递矩阵h00和h01的维度
    transfer = np.zeros((2*dim, 2*dim))*(0+0j)  # 0+0j用来转为复数,不然下面赋值会提示忽略了虚数部分
    transfer[0:dim, 0:dim] = np.dot(np.linalg.inv(h01), fermi_energy*np.identity(dim)-h00)   # np.dot()等效于np.matmul()
    transfer[0:dim, dim:2*dim] = np.dot(-1*np.linalg.inv(h01), h01.transpose().conj())
    transfer[dim:2*dim, 0:dim] = np.identity(dim)
    transfer[dim:2*dim, dim:2*dim] = 0  # a:b代表 a <= x < b
    return transfer  # 返回转移矩阵


def green_function_lead(fermi_energy, h00, h01, dim):  # 电极的表面格林函数
    transfer = transfer_matrix(fermi_energy + 1e-11j, h00, h01, dim)
    eigenvalue, eigenvector = np.linalg.eig(transfer)
    ind = np.argsort(np.abs(eigenvalue))
    temp = np.zeros((2*dim, 2*dim))*(1+0j)
    i0 = 0
    for ind0 in ind:
        temp[:, i0] = eigenvector[:, ind0]
        i0 += 1
    s1 = temp[dim:2*dim, 0:dim]
    s2 = temp[0:dim, 0:dim]
    s3 = temp[dim:2*dim, dim:2*dim]
    s4 = temp[0:dim, dim:2*dim]
    right_lead_surface = np.linalg.inv(fermi_energy*np.identity(dim)-h00-np.dot(np.dot(h01, s2), np.linalg.inv(s1)))
    left_lead_surface = np.linalg.inv(fermi_energy*np.identity(dim)-h00-np.dot(np.dot(h01.transpose().conj(), s3), np.linalg.inv(s4)))
    return right_lead_surface, left_lead_surface  # 返回右边表面格林函数和左边表面格林函数


def self_energy_lead(fermi_energy, h00, h01, width, length):  # 电极的自能
    h_LC = matrix_LC(width, length)
    h_CR = matrix_CR(width, length)
    right_lead_surface, left_lead_surface = green_function_lead(fermi_energy + 1e-12j, h00, h01, width)
    right_self_energy = np.dot(np.dot(h_CR, right_lead_surface), h_CR.transpose().conj())
    left_self_energy = np.dot(np.dot(h_LC.transpose().conj(), left_lead_surface), h_LC)
    return right_self_energy, left_self_energy  # 返回右边电极自能和左边电极自能


def Green_n(fermi_energy, h00, h01, width, length):  # 计算G_n
    fermi_energy = fermi_energy + 1e-3j
    right_self_energy, left_self_energy = self_energy_lead(fermi_energy, h00, h01, width, length)
    hamiltonian = matrix_center(width, length)
    green = np.linalg.inv(fermi_energy*np.identity(width*length)-hamiltonian-left_self_energy-right_self_energy)
    right_self_energy = (right_self_energy - right_self_energy.transpose().conj())*(0+1j)
    left_self_energy = (left_self_energy - left_self_energy.transpose().conj())*(0+1j)
    G_n = np.imag(np.dot(np.dot(green, left_self_energy), green.transpose().conj()))
    return G_n


if __name__ == '__main__':
    main()
